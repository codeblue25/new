---
layout: post
title: "[백준 / Python] 카드2"
date: 2021-08-04T15:25:52-05:00
author: codeblue25
categories: Algorithm
---

<h2>문제</h2>

N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.<br  />
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.<br  />
예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.<br  />
N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

<h2>제한사항</h2>

- 첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.

<h2>🔹나의 풀이</h2>

<h3>첫번째 풀이</h3>

```python
cards = list(map(str, range(1, int(input())+1)))
turn = 1
while len(cards) > 1 :
    if turn % 2 == 1:
        cards.pop(0)
    elif turn % 2 == 0:
        cards.append(cards[0])
        cards.pop(0)
    turn += 1

print(''.join(cards)) 
```
결과: **시간 초과**<br/>
피드백: while문을 돌 때마다 if, elif로 나눌 필요x, 꼭 숫자를 문자열로 변환할 필요x

<h3>두번째 풀이</h3>

```python
cards = list(range(1, int(input())+1))
turn = 1
while len(cards) > 1 :
    if turn % 2 == 0:
        cards.append(cards[0])
    cards.pop(0)
    turn += 1

print(cards[0])
```
결과: **시간 초과**<br/>
피드백: 시간복잡도가 O(N**2)이기 때문에, 최대 연산 횟수가 대략 2500억번(..)

<h3>세번째 풀이</h3>

```python
from collections import deque

cards = deque(list(range(1, int(input())+1)))
while len(cards) > 1 :
    cards.popleft()
    cards.append(cards.popleft())

print(cards[0])
```
결과: **맞았습니다!!**<br/>

<h3>🔶다른 사람의 풀이</h3>

```python
n,s=int(input()),1
while s<n:
    s*=2
print(s if s==n else 2*n-s)
```

_숏코딩..간지작살;;_